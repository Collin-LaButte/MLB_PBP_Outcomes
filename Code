import pandas as pd
import statsmodels.api as sm

data = pd.read_excel("2019_pitches.xlsx")
print(data.head())

print(data[['pitch_type', 'Batter', 'inning', 'b_count', 's_count', 'outs', 'on_1b', 'on_2b', 'on_3b', 'batter_hand', 'pitcher_throw', 'type']].head())

from sklearn.model_selection import train_test_split
data_half1, data_half2 = train_test_split(data, test_size=0.5, random_state=42)

# Correlation Matrix
import seaborn as sns
correlation_matrix = data_half1.corr()

plt.figure(figsize=(17, 12))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

selected_vars = ["Batter", "pitch_type", "inning", "b_count", "s_count", "outs", "on_1b", "on_2b", "on_3b", "batter_hand", "pitcher_throw", "type"]
data_subset = data_half1[selected_vars]

outcome_counts = data_subset["type"].value_counts()
proportions = outcome_counts / outcome_counts.sum()*100
print(outcome_counts)
print(proportions)

data_subset = data_half1[selected_vars].copy()
data_subset["type"] = pd.Categorical(data_subset["type"]).codes

code_counts = data_subset["type"].value_counts()
print("Code -> Count:")
for code, count in code_counts.items():
    print(f"{code} -> {count}")

data_subset = pd.get_dummies(data_subset, columns=["Batter","pitch_type", "inning", "batter_hand", "pitcher_throw"], drop_first=True)

X = data_subset.drop("type", axis=1)
y = data_subset["type"]

from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder

logreg_model = LogisticRegression(penalty='l2', max_iter=100)
logreg_model.fit(X, y)

new_data = pd.DataFrame({
    "pitch_type": [""],
    "inning": [1],             #EDIT
    "b_count": [1],            #EDIT
    "s_count": [2],            #EDIT
    "outs": [1],               #EDIT
    "on_1b": [0],              
    "on_2b": [0],       
    "on_3b": [0],
    "batter_hand": [""],
    "pitcher_throw": [""],
    "Batter_Mookie Betts": [1], #EDIT
    "pitch_type_CU": [1],       #EDIT
    "pitcher_throw_R": [1]
})

new_data = pd.get_dummies(new_data, columns=["pitch_type", "batter_hand", "pitcher_throw"], drop_first=True)

print(new_data.head())

missing_cols = set(X.columns) - set(new_data.columns)
for col in missing_cols:
    new_data[col] = 0


new_data = new_data[X.columns]
print(new_data.head())

predicted_probs = logreg_model.predict_proba(new_data)
class_names = {
    0: "Ball in dirt",
    1: "Ball",
    2: "Called strike",
    3: "In play, no out",
    4: "In play, runs",
    5: "Foul",
    6: "Hit by pitch",
    7: "Foul bunt",
    8: "Missed bunt",
    9: "Swining pitchout",
    10: "Pitchout",
    11: "Swining strike",
    12: "Foul tip",
    13: "Intentional ball",
    14: "Swinging strike (Blocked)",
    15: "In play, outs"
}

sorted_predictions = sorted(zip(class_names.values(), predicted_probs.T), key=lambda x: x[1], reverse=True)

for class_num, (class_name, probs) in enumerate(sorted_predictions, start=1):
    print(f"Class Name: {class_name} {probs}")

import matplotlib.pyplot as plt

# Assuming class_names and predicted_probs are defined

# Sorting predictions
sorted_predictions = sorted(zip(class_names.values(), predicted_probs[0]), key=lambda x: x[1], reverse=True)

# Unzip the sorted predictions to get class names and corresponding probabilities
sorted_class_names, sorted_probs = zip(*sorted_predictions)

# Print the sorted predictions
for class_num, (class_name, probs) in enumerate(sorted_predictions, start=1):
    print(f"Class Name: {class_name} {probs}")

# Plotting the horizontal bar chart
plt.figure(figsize=(10, 6))
bars = plt.barh(sorted_class_names, sorted_probs, color='blue')  # No need to multiply by 100 for percentages
plt.xlabel('Probability')
plt.ylabel('Outcome')
plt.title('Probabilities for Outcome')

# Set the x-axis limits to show 0 to 1 (probabilities)
plt.xlim(0, 1)

# Invert the y-axis to have the highest probability on top
plt.gca().invert_yaxis()

# Add labels on the outside of each bar
for bar, prob in zip(bars, sorted_probs):
    plt.text(bar.get_width() + 0.01, bar.get_y() + bar.get_height() / 2, f'{prob:.4f}', ha='left', va='center')

plt.tight_layout()

# Display the plot
plt.show()
